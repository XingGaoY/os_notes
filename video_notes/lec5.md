# 计算机体系结构和内存层次
- 操作系统的内存管理
由内存管理单元将内存：
	- 抽象：逻辑地址空间
	- 保护：独立地址空间
	- 共享：访问相同内存
	- 虚拟化：更大的地址空间
- 内存管理方式
依赖计算机架构，需要MMU支持
	- 重定位
	- 分段：代码、数据、堆栈
	- 分页
	- 虚拟存储
# 地址空间和地址生成
- 物理地址空间：硬件支持的地址空间$[0, MAX_{sys}]$
- 逻辑地址空间：在CPU运行的进程看到的地址$[0, MAX_{prog}]$
- 逻辑地址生成：源代码 --*编译*-->汇编码--*编译*-->机器码--*链接*-->确定文件内的地址--加载（重定位）-->逻辑地址
	- 编译时：
		- 写死的程序，起始地址已知
		- 如果起始地址改变，则需要重新编译
	- 加载时：
		- 如果起始地址未知，编译器需要生成可重定位的代码
		- 加载时，生成绝对地址
	- 执行时
		- 执行时代码可移动
		- 需要地址转换硬件支持
- 地址生成过程
	- CPU
		- ALU需要逻辑地址的内存内容
		- MMU：进行逻辑地址和物理地址转换
		- CPU控制逻辑：给总线发送物理地址请求
	- 内存
		- 发送物理地址内容给CPU
		- 或接收CPU数据到物理地址
	- 操作系统
		- 建立逻辑地址LA到物理地址PA的映射
- 地址检查
	- 指令运行
	- 得到逻辑地址
	- 检查段长度和偏移量，报内存异常或者进入下一步（段长度）
	- 和段基址求和得到物理地址（段基址）

# 连续内存分配
给进程分配一块不小于指定大小的连续物理内存区域
- 外部碎片：分配单元之间未被使用内存
- 内部碎片：分配单元内部未被使用的内存。例如分配单元大小取整。
- 动态分区分配
当程序被加载时，分配一个进程指定大小可变的分区（分区地址连续）
	- 维护的数据结构
		- 所有进程的已分配分区
		- 空闲分区
	- 动态分区分配策略
		- 最先匹配
		- 最佳匹配
		- 最差匹配
	- 最先匹配：分配n个字节，使用**第一个可用的空间比n大的空闲块**。
		- 空闲分区列表按地址顺序排序
		- 分配时搜索一个合适的分区
		- 释放时检查是否可以和临近的分区合并
		- 优点：
			- 简单
			- 高地址有大块的空闲分区
		- 缺点：
			- 外碎片
			- 分配大块时较慢（碎片增加，增大了搜索的开销）
	- 最佳匹配：分配n个字节，查找并使用**不小于n的最小空闲分区**。
		- 空闲分区列表按大小排序
		- 分配时，查找一个合适的分区
		- 释放时，查找合并**地址临近**的空闲分区
		- 优点：大部分分配的尺寸较小，效果很好
			- 避免大的空闲分区被拆分
			- 减小外部碎片大小
			- 相对简单
		- 缺点：
			- 外碎片
			- 释放分区较慢
			- 容易产生很多无用小碎片
	- 最差匹配：分配n个字节，使用**尺寸不小于n的最大空闲分区**
		- 空闲分区列表由大到小排序
		- 选最大的分区
		- 检查和临近分区合并，重新插入
		- 优点：
			- 中等大小碎片较多时，效果最好
			- 避免出现太多小碎片
		- 缺点：
			- 释放分区较慢
			- 外碎片
			- 容易破坏大的空闲分区

# 碎片整理
通过调整进程占用的分区位置来减少或者避免分区碎片
- 碎片紧凑：通过移动分配给内存的内存分区，合并外部碎片
	- 要求：应用程序可以动态重定位
- 分区对换：通过抢占并回收处于**等待状态**进程的分区，以增大可用内存空间

# 伙伴系统
整个可分配大小为2_U，每次分配大于等于需要大小的最小的2的幂，划分点必须在2的幂的位置。
