# 非连续内存分配的需求背景
- 连续分配的缺点
	- 分配的物理内存必须连续
	- 存在外碎片和内碎片
	- 内存分配的动态修改困难
	- 内存利用率较低
- 非连续分配：提高内存利用效率和管理灵活性
	- 允许一个程序使用非连续的物理地址空间
	- 允许共享代码和数据
	- 支持动态加载和动态链接
- 要解决的问题
	- 虚拟地址和物理地址的转换
		- 软件实现（灵活，开销大）
		- 硬件实现（够用，开销小）

# 段式存储管理
- 段地址空间：进程的段地址空间由多个段组成
	- 主代码段
	- 子模块代码段
	- 公共库代码段
	- 堆栈段
	- 堆数据
	- 初始化数据段
	- 符号表等
- 目的：更小的粒度，更灵活的分离和共享
- 不连续的二维结构：各个段的内部地址是连续的，但是不会互相访问。到实际内存中段与段之间是不连续的。
- 段访问机制：
	- 段表示**访问方式**和**存储数据**等属性相同的一段地址空间
	- 对应一个连续内存“块”
	- 若干个段组成进程逻辑地址空间
	- 逻辑地址由二元组(s, addr)表示：s段号，addr段内偏移
- 段访问的硬件实现
	- 通过段号确定段表中的位置，得到基址和长度
	- MMU比较偏移和长度，检测异常
	- 将偏移和基址相加，得到地址

# 页式存储管理
- 页帧（物理页面，Frame）：把物理地址空间划分为大小相同的基本分配单位，2的整数次幂
	- 内存物理地址：二元组（f, o），f帧号(F位，共2^F个帧），o为帧内偏移（S位，每页2^S字节），物理地址：$F*2^S+o$
- 页面（逻辑页面，Page）：把逻辑地址划分为相同大小的基本分配单位，帧和页的大小一致
	- 类似帧
	- 不是所有的页都有对应的帧
- 转换：页表（保存转换关系），MMU/TLB
	- CPU得到逻辑地址(p, o)
	- 找到页表（保存帧号）
	- 通过页号p和页表基址相加得到帧号
	- 由于偏移量一致，将帧号左移s位和偏移相加得到物理地址

# 页表概述
- 每个进程对应一个页表项
	- 每个页面对应一个页表项
	- 随进程运行状态动态变化
	- 有页表基址寄存器，和页表偏移相加得到f帧号
	- 页表中有标志项：存在位、修改位、引用位
- 访问性能：访问一个内存单元需要2次内存访问：获得页表项、访问数据
- 大小问题：页表可能会非常大

# 快表和多级页表
- 快表：把近期访问过的页表项访问在CPU的存储器中，CPU可以同时查找所有的项，如果命中，直接获得对应物理页号，未命中，如之前的访问方法，同时更新TLB
- 多级页表：将页号分为若干级，每一级的项数和该级的位数一致。由于不是所有的页表地址都会得到使用，可以节省大量的空间

# 反置页表
实际页帧对应相应的进程号和逻辑地址
- 每一个帧和一个页寄存器关联，同时有使用位，占用页号和保护位
- 优点
	- 页表大小相对很小
	- 页表大小和逻辑地址大小无关
- 缺点
	- 页表信息对调后，需要依据帧号找到页号
	- 页寄存器中搜索逻辑地址中的页号
- 搜索方式：对逻辑地址Hash，在快表中找对应的项，解决对应的冲突，遍历所有的冲突页表项。

# 段页式存储管理
段式中保存相同类的数据，在内存保护方面有优势。页式有利于管理和分配。
- 在段式存储管理基础上，给每个段加一级页表
- 内存共享，添加一个共享段：指向相同的页表基址，实现段共享
