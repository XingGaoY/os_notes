# 虚拟存储的需求背景
- 系统内存不足
	- 覆盖：应用程序手动把指令和数据保存在内存中
	- 交换：操作系统暂时吧不能执行的程序保存在外存中
	- **虚拟存储：在有限容量的内存中，以页为单位自动装入更多更大的内存**

# 覆盖和交换
- 覆盖
	- 在较小的可用内存中运行较大的程序
	- 依据程序逻辑结构，将程序划分为若干**功能相对独立**的模块，将不会同时执行的模块**共享同一块内存区域**
		- 必要部分（常用功能）常驻内存
		- 可选部分（不常用功能）放在其他程序模块中，只在需要时装入内存
		- 不存在调用关系的模块可以相互覆盖，共用内存
	- 将不依赖的模块分组，选择该组中最大的块的大小作为该组的大小，运行时交换模块即可
	- 增加编程困难、增加执行时间（时间换空间）
- 交换
	- 增加正在运行或者需要运行的程序的内存
	- 将可暂时不运行的程序放到外存，基本单位是整个内存空间
	- 交换时机：只在内存不足或有可能性时换出
	- 交换区大小：存放所有用户内存镜像
	- 换入位置：需要重定向技术

# 局部性原理
- 目标
	- 只将一部分程序加载到内存中，从而运行比物理内存大的程序
		- 有操作系统完成
	- 实现进程在内外存交换，获得更大的空闲内存空间
		- 只交换部分内容
- 局部性原理
	- 程序在执行过程中的较短时间，所执行的指令地址和操作数地址，分别局限于一定的区域
	- 时间局部性：一条指令的执行和下次执行，一个数据的一次访问和下次访问集中在一个较短时期内
	- 空间局部性：当前指令和临近指令，当前访问的数据和临近访问的数据集中在较小的区域内
	- 分支局部性：一条跳转指令的两次执行，可能跳转到相同的内存位置

# 虚拟存储
将不常用的部分内存块暂存到外存
- 原理：
	- 装载时，只将当前指令执行需要的部分页面或者段放入内存，就启动运行
	- 执行时缺页：运行时发现需要代码或者数据时，发出缺页异常，通知操作系统将相应页面或段从外存调入内存
	- 在页式存储管理的基础上，增加请求掉页和页面置换
- 地址转换
	- 同页式存储基本一致，在页表中增加标志位，表明是否在物理内存中
	- 如不在内存，报缺页异常，将页面换入
	- 标志位
		- 驻留位：是否在内存中，不在，则报缺页异常
		- 修改位：回收该页面时（驻留位有效），判断是否需要写会外存
		- 访问位：表明这个位是否被经常访问
		- 保护位：表明允许访问方式

# 缺页异常
- 缺页异常
	- 进入缺页异常服务例程
	- 查找外存中页面
	- 页面换入
	- 修改页表项
	- 重新执行导致异常的指令

- 换入换出
	- 有空闲页面，分配物理页帧之后，将页面换入
	- 根据页面置换算法选择被替换的物理页帧和对应的逻辑页
	- 如果被替换的页被修改过，则写会外存，并修改该页页表项的驻留位为0
- 保存未被映射的页
能很快地找到外存中的页面内容：交换空间，用特殊格式存储未被映射的页面，例外：
	- 代码段：可执行文件
	- 共享库：动态加载
- 性能
	- EAT有效存储访问时间 = 访存时间*(1-p) + 缺页异常处理时间*缺页率p
	- 需要尽力降低缺页率（不同的页面置换算法）
