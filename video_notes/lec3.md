#BIOS
第一条指令在内存中。初始化代码在ROM中。
BIOS固件中保存：
	CS：IP = 0xf000:fff0（CS：代码段寄存器；IP：指令指针寄存器）
	PC = 16*CS+IP
	系统处于实模式
	由于地址总线只有20位，保存在1M以下。

所以：
- -BIOS-将加载程序从磁盘的引导扇区加载到0x7c00
- -加载程序-将操作系统的代码和数据段加载到内存中，跳转到os起始地址

磁盘中有文件系统，BIOS不需要认识所有的文件系统，由加载程序识别，并且将操作系统内核代码
加载到内存中。

BIOS提供基本I/O：
INT 10h: 字符显示
INT 13h：磁盘扇区读写
INT 15h：检测内存大小
INT 16h：键盘输入
并且只能在实模式下工作

#系统启动
BIOS找到主引导记录代码，读取活动分区的引导扇区代码，再来加载引导程序

CPU加电后从0XFFF0读取第一条指令（跳转）
初始16位实模式，找到指令指针。

进入BIOS
- 硬件自检， 检测内存显卡等工作情况，进行设备初始化
- 执行系统BIOS，进行系统检测，检测配置系统中安装的即插即用设备
	更新CMOS中扩展配置数据ESCD（Extended System Configuration Data）
- 控制权交给启动扇区

主引导记录MBR
- 启动代码446字节
	-检查分区表正确性
	-加载并跳转到正确引导程序
- 硬盘分区64字节
	-描述分区状态和位置
	-每个分区描述信息16字节
- 结束标志字2字节
	-主引导记录的有效标志55aa
		-恰好为占空比为0.5的方波，且完全擦写了每一位，确认正常

进入活动分区的引导扇区
- 跳转指令（JMP）： 跳转到启动代码，-和平台相关-
- 文件卷头：文件系统描述信息
- 启动代码： 跳转到加载程序
- 结束标志：55aa

bootloader（加载程序）
-从文件系统中读取启动配置文件
	-可以识别文件系统
	-配置文件随os改变，安全模式，内核参数之类
-依据配置加载指定内核，并且跳转执行

系统启动规范
- BIOS
	- 固定到主板上
	- 包括系统配置、自检程序和系统自启动程序
	- MBR描述4个分区；GPT全局描述分区表，描述多个分区；PXE网络启动
- UEFI同一可扩展固件接口
	- 在所有平台上一致的操作系统服务

#中断异常和系统调用
- 计算机运行中，内核是值得信任的
- 只有内核可以执行特权指令
- 方便应用程序

- 对于外设的反应
- 异常行为
- 获得系统服务

内核的进入和退出
- 系统调用（同步或异步）
	应用程序主动向操作系统发出服务请求，找到函数库，通过系统调用接口，
	进入内核中，访问中断向量表-->系统调用表-->系统调用实现，最后返回。
- 异常（同步）
	非法指令或其他原因导致的指令执行失败后的处理请求。出现异常（代码执行出错）
	进入内核中断向量表-->异常服务例程处理出错内容
- 中断（异步）
	外部设备产生中断-->中断向量表-->设备驱动完成请求

中断处理机制
- 在cpu初始化时设置中断使能标志
	- 中断标志表
	- 依据不同标志调用不同处理
- 软件（Check the implementation from this point）
	- 现场保存（编译器）
	- 中断服务处理（服务例程）
	- 清楚中断标记（服务例程）
	- 现场恢复（编译器）

中断嵌套
- 硬件中断服务例程可被打断
	不同硬件中断源可能在处理中断时出现
	硬件中断服务例程需要临时禁止中断请求
	中断请求会保持到cpu做出响应
- 异常服务
	异常处理中可能出现硬件中断
- 异常服务嵌套（check）
	处理异常服务例程可能出现缺页

#系统调用
例子：
printf()，向下调用系统调用write()。

实现：
- 每个系统对应一个系统调用号
- 系统调用接口根据系统调用号来维护表的索引

系统调用：INT IRET，系统调用，堆栈切换和特权级切换
函数调用：CALL RET，常规调用，没有堆栈切换

开销
系统调用更安全？开销更大
- 引导机制
- 建立内核堆栈
- 验证参数
- 内核态映射到用户态的地址空间
	- 更新页面映射状态
- 内核态独立地址空间
	- TLB

#系统调用实例
视频3-05，VITAL
