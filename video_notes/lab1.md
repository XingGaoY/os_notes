# x86-32硬件
80386四种运行模式：
- 实模式
- 保护模式
- SMM模式
- 虚拟8036模式

**实模式**：兼容早期16位机器，加电启动便进入该模式，访问物理内存不超过
1MB； 
**保护模式**：支持32位寻址；支持内存分页，提供对于虚拟内存支持；支持多任务，优先级机制

地址：
- **物理地址**：是处理器提交到总线上，访问内存和外设的最终地址。一个计算机系统只有一个物理地址
- **线性地址**：是段模式下，程序认为的自己独占的整个计算机地址空间地址。
- **逻辑地址**：应用程序直接使用的地址空间。

1. **段机制启动、页机制未启动**：逻辑地址--*段机制*-->线性地址=物理地址
1. **段、页机制都启动**：逻辑地址--*段机制*-->线性地址--*页机制*-->物理地址

寄存器分为8组：
- 通用寄存器
 - EAX：累加器
 - EBX：基址寄存器
 - ECX：计数器
 - EDX：数据寄存器
 - ESI：源地址指针寄存器
 - EDI：目的地址指针寄存器
 - EBP：基址指针寄存器
 - ESP：堆栈指针寄存器
其中后四个又是变地址寄存器，对于低16位的存取，不影响高16位的数据。
- 段寄存器
 -用于寻址，例如CS代码段寄存器
- 指令指针寄存器
 - EIP低16位是8086的IP，储存下一条要执行指令的内存地址；进入保护模式分段地址转换中，表示指令的段内偏移地址。
- 标志寄存器
 - IF：中断允许标志位，由CLI，STI两条指令控制；设置IF使CPU识别外部中断请求（可屏蔽），复位则禁止中断。IF对不可屏蔽外部中断和故障终端的识别没有任何作用。
- 控制寄存器
- 系统地址寄存器、调试寄存器、测试寄存器
后两个一般给操作系统这类使用
# x86启动顺序

寄存器初始化
EIP = 0000FFF0H，CS = F000H

- 实模式实际地址：
  $Base + EIP = FFFF0000H + 0000FFF0H = FFFFFFF0H$ 
  该位置是BIOS的EPROM所在地
  CS重新加载后，地址转换开始起作用
  通常第一条指令是长跳转指令（CS、EIP得到更新）到BIOS代码中执行。

- BIOS加载MBR的512字节加载到0x7c00
  然后跳转，开始执行0x7c00的第一条指令

- bootloader做的事
 - 使能保护模式和段机制
 - 从硬盘读取kernel in ELF格式的ucore kernel，并放到内存中固定位置
 - 跳转到ucore中

- 段机制
 - 段寄存器指向段描述符，包含起始地址和大小。
  由于还有页机制，段尽量简单，起始地址为0，段落大小4G，uCore基本没有起到分段功能
 - 启动保护模式后，段机制自然启动。
 - 段寄存器中，有段选择子Index，查找段描述符表，找到段描述符，获得起始地址
加上offset后获得线性地址，由于无页机制，线性地址即为实际地址。
 - 全局描述符表（GDT），由bootloader建立，描述好空间和大小，由命令lgdt，建立好GDT。由GDTR保存GDT入口地址和表长信息。 
 - 段选择子：高13位GDT Index，TI表示是LDT还是GDT，之后RPL两个bit表示四个特权级

- 使能保护模式
  将CR0设置某一位为0（PE）

- 加载ELF格式的uCore OS kernel
  从ELF header中获得proghdr位置，读出虚存地址va，找到起始位置和大小，用来在内存中存放uCore的代码段和数据段。由于无文件系统，直接将扇区读入。
